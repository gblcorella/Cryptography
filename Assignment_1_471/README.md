Assignment 1 Cryptography
CPEG 471


1) [20 points] Implement the Vigenere decryption algorithm and provide 5 ptxt/ctxt pairs to demonstrate its correctness.

2) [15 points] Implement a program that calculates the frequency each letter appears in a given string and demonstrate its correctness using the first 10 paragraphs of Lorem Ipsum from https://www.lipsum.com/ (Links to an external site.)

3) [20 points] Implement a randomized semantically secure cipher based on the blue print discussed in class and the textbook, and demonstrate its correctness using 5 ptxt/ctxt pairs.

4) [15 points] Can you prove that the construction you implemented in question 3 above is semantically secure? In you answer, also discuss any assumptions you have made.

5) [30 points] Write a program to break a "many-time-pad" (i.e., the vulnerable version of OTP that reuses its secret key more than once). You have captured 10 hex-encoded ciphertexts that have been encrypted using the same key with OTP:


004e0c1c1c090c1a0d49081f001d1b4541430b0f100854060d04450c12001506411d440c1d540854094f1011080c0b45551c0e1e1d121d450106411706010d450e0a451046

004e43131110040d1f49081f00081d00084e10041a1549000c0b094315430048030d001e1b490248500e1c54040c180c540b4511061116081e0012541d004e451907441148164502060106171041070c1d184901000757040b0a0017074f0505110b541d0e0c450145021b16491559551e0618490c1f000e135409451d0d1a17041947

0055171a000a1107170815054f075349120010091141501d0d09001007001b0e4102451b1a4618491e08521541010004491f45041a0407450f54120d1a1b0b4d4f034e00011159411c014f101012000c024e5207161b0217060b00090f534905450d111b12080c1c00001a10520842001a0c54560e0a55045b

0541171345070a00120005094e1d1a410d4910185408534f1602004304521b180406541053540941044f161515034c0c53520b1f0645170c1d170d1b1a0a0a001b090007111654041e530a0d1d0800000a1d00170b181216164e54090b59490c04181149040c001c00001b10480e521c140c10001b09000a1b1b1f451a1c0c4305151d0e40

05411713450d0b1a110e130554105349120010091141501d0d1a00110059541c091554491741154150071307410c0311001000151c45100d0f1a06110d434e440a155406071c45055f530011490d1b1a1b4e490c45151945100041141a4806160c14110d4606175241020d0d44044e010f05544d0e084e04075a

11520a0404071c4e1d1a4118480c535208470c15540e464f030445061a541d1c185800081054084e174f1b1a410b1816001d121e5207160d0f180758491b01000b0354111a08490f16531b0b0c41100c081c450745001845120649020600001045191d050a490c1c54041c0543150002071d1c0006125341101a1e0c1c1b070e041a1d434e49070d0a1a16040f13491b064900050b0352110d41004f43160649010d00041a00530000000c105946060100021a094c00004756111d491511081c0200081a534914001c07061a184c43050f0f0217094116104f0f4e570c1a1c491b0d48111a125a

137322520c17450f1a4900004706014915480941120e524f03191c0e1945001a0817000a015911541f080015110a1549001b0b06170b07000a54081a495e57175846420d48374f0f532106150c1200454f2f440b45271f040807524d4e410700452211060808171600200a08450c411b40

0055171a0a160c14151d08034e491a5341410a411511501d0d1c040f54541c091554491a534713411e1b17104116034541521609011116084e110f00001b17001b0900150b06451200530e431a18071d0a03001000071810170d454f

0000001d1301171a540a090d4e07164c41491741150f001a0c030b17114e100d05544f1b53550f41051b1a1b130b160044520c1e061712481d0d12000c024e4307074e1a0d0900151b121b430c0f150b030b53421103184506014f110b5208100c0013490307111b54080b1700154f551a1b154e1c004513551d060301060402151d06014e49074e074f050c18541d070f580017070b4c151c04070017090b00111c5304170854164e070007551406065955030a4c000d595607071d461d060b14000f015449011d0d110c1059540b09410c03110d540b1c53464e41060d111a075941011c091b52080e1511041f1a000e

0000001b150c001c000c19180d061d4c1800051500004304420316431500171a180454081d410d590306015415070f0d4e1b140517451a0b4e03091d0a074e540703001506044c1800074f171b08111a4f1a4f42011103001703490f0b001d0c004e1f0c1f49161d4c04021d0007521a03491f4e00114c0411130d450112490a0f000c1d0d45191a030b520e0804010a1c0c540416100e

Your goal is to recover the plaintext hidden in the following hex-encoded "challenge ciphertext", which has also been encrypted using the same OTP key as the previous 10:

084e43011c09080b001b080f000a015911540b06060050071b4a110b11001504061b520007480c53501a0111411604000001041d174518001754071b1b4f0c4f1b0e0011060652180307060c074115070b4e440706060e1511074f0f40

Hint 1: the XOR operation of the OTP can be implemented as follows (in Python):

def xor(X, Y): return "".join([chr(ord(a) ^ ord(b)) for (a, b) in zip(X, Y)])

Hint 2: What is the result range if you XOR a space character with any upper (A-Z) or any lower case (a-z) character? Is this range different from when you XOR any upper or lower case character with another upper or lower case character?

Hint 3: All original plaintexts include space characters. How can you use this additional information to recover characters of the reused OTP key?

Hint 4: If you cannot recover all characters in the "challenge ciphertext" using your program, can you guess what are the missing characters?
